import { json } from '@sveltejs/kit';
import type { RequestHandler } from './$types';
import XLSX from 'xlsx';
import {
  FLIPKART_TOKEN,
  FLIPKART_LOCATION_ID,
  SHOPIFY_SHOP,
  SHOPIFY_API_TOKEN,
  SHOPIFY_LOCATION_ID,
  SHOPIFY_VITASHOP_SHOP,
  SHOPIFY_VITASHOP_API_TOKEN,
  SHOPIFY_VITASHOP_LOCATION_ID,
  SHOPIFY_NATURTINT_SHOP,
  SHOPIFY_NATURTINT_API_TOKEN,
  SHOPIFY_NATURTINT_LOCATION_ID,
  MYNTRA_SECRET_KEY,
  MYNTRA_MERCHANT_ID
} from '$env/static/private';

const normalizeSku = (sku: string) => (sku || "").trim().toLowerCase();

// Retry utility function
async function retryFetch(
  url: string,
  options: RequestInit,
  maxRetries: number = 3,
  delayMs: number = 1000
): Promise<Response> {
  let lastError;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      // Log the request details for debugging
      if (url.includes('vitashop')) {
        console.log(`[Vitashop] Attempt ${attempt}/${maxRetries} - URL: ${url}`);
        console.log(`[Vitashop] Headers:`, options.headers);
        console.log(`[Vitashop] Has agent:`, !!options.agent);
      }

      const response = await fetch(url, options);

      // Log response for Vitashop
      if (url.includes('vitashop')) {
        console.log(`[Vitashop] Response status: ${response.status} ${response.statusText}`);
      }

      // If successful or client error (4xx), don't retry
      if (response.ok || (response.status >= 400 && response.status < 500)) {
        return response;
      }

      // For 5xx errors, retry
      if (response.status >= 500) {
        lastError = new Error(`HTTP ${response.status}: ${response.statusText}`);
        console.log(`Attempt ${attempt}/${maxRetries} failed with status ${response.status}, retrying...`);
      } else {
        return response; // Return other responses without retry
      }
    } catch (error: any) {
      lastError = error;
      console.log(`Attempt ${attempt}/${maxRetries} failed with error:`, error.message);

      // More detailed logging for Vitashop
      if (url.includes('vitashop')) {
        console.error(`[Vitashop] Full error:`, error);
        if (error.cause) {
          console.error(`[Vitashop] Error cause:`, error.cause);
        }
      }
    }

    // Wait before retrying (exponential backoff)
    if (attempt < maxRetries) {
      const waitTime = delayMs * Math.pow(2, attempt - 1);
      console.log(`Waiting ${waitTime}ms before retry...`);
      await new Promise(resolve => setTimeout(resolve, waitTime));
    }
  }

  throw lastError || new Error('Max retries exceeded');
}

export const POST: RequestHandler = async ({ request }) => {
  const body = await request.json();
  const { inventory, marketplace} = body;
//   console.log(body);
//   console.log(marketplace);
//   console.log(inventory);

  if (!Array.isArray(inventory)) {
    return json({ error: "Inventory data must be an array." }, { status: 400 });
  }

  const handlers: Record<string, () => Promise<any>> = {
    // ------------------ Flipkart ------------------
    flipkart: async () => {
      const token = FLIPKART_TOKEN;
      const locationId = FLIPKART_LOCATION_ID;
      const status: Record<string, string> = {};

      for (let i = 0; i < inventory.length; i += 10) {
        const batch = inventory.slice(i, i + 10);
        const payload: Record<string, any> = {};

        for (const item of batch) {
          if (!item.fsn || item.fsn.startsWith("❌")) {
            status[item.sku] = "❌ FSN missing";
            continue;
          }
          payload[item.sku] = {
            product_id: item.fsn,
            locations: [{ id: locationId, inventory: item.qty }]
          };
        }

        console.log(JSON.stringify(payload));

        if (Object.keys(payload).length === 0) continue;

        try {
          const response = await retryFetch(
            "https://api.flipkart.net/sellers/listings/v3/update/inventory", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${token}`,
              },
              body: JSON.stringify(payload),
            },
            3, // max retries
            1000 // initial delay
          );

          // Try to parse response, handle potential JSON errors
          let result: any;
          try {
            const responseText = await response.text();
            result = JSON.parse(responseText);
          } catch (jsonErr: any) {
            console.error('Failed to parse Flipkart response:', jsonErr.message);
            // If JSON parsing fails, treat all items in batch as failed
            batch.forEach(item => {
              status[item.sku] = `❌ Invalid response from Flipkart: ${jsonErr.message}`;
            });
            continue; // Skip to next batch
          }

          batch.forEach((item) => {
            if (!payload[item.sku]) return;

            const skuResult =
              result[item.sku] ||
              Object.entries(result).find(
                ([key]) => key.trim().toLowerCase() === item.sku.trim().toLowerCase()
              )?.[1];

            if (!skuResult) {
              status[item.sku] = `❌ No response from Flipkart`;
              return;
            }

            if (skuResult.status === "SUCCESS") {
              status[item.sku] = "✅ Success";
              return;
            }

            const errorMessages = [];
            if (skuResult.errors?.length)
              errorMessages.push(...skuResult.errors.map((e: any) => e.description || e.message));
            if (skuResult.attributeErrors?.length)
              errorMessages.push(...skuResult.attributeErrors.map((e: any) => e.description || e.message));

            status[item.sku] = errorMessages.length ? `❌ ${errorMessages.join("; ")}` : `❌ Status: ${skuResult.status}`;
          });
        } catch (err: any) {
          batch.forEach(item => {
            status[item.sku] = `❌ ${err.message || "Network Error"}`;
          });
        }
      }

      return status;
    },

    // ------------------ PTFS ------------------
    ptfs: async () => {
      // Import https module for SSL workaround
      const https = await import('https');
      const agent = new https.Agent({
        rejectUnauthorized: false // Bypass SSL verification
      });

      const store = {
        shop: SHOPIFY_SHOP,
        token: SHOPIFY_API_TOKEN,
        locationId: SHOPIFY_LOCATION_ID,
      };

      const status: Record<string, any> = {};

      for (const item of inventory) {
        const sku = normalizeSku(item.sku);
        const variantId = item.asin;
        const inventoryId = item.fsn;

        if (!variantId || !inventoryId) {
          status[sku] = { qty: "❌ Missing IDs", price: "❌", mrp: "❌" };
          continue;
        }

        const results: Record<string, string> = {};

        // Update inventory
        try {
          const invUrl = `https://${store.shop}.myshopify.com/admin/api/2024-10/inventory_levels/set.json`;
          const invRes = await retryFetch(invUrl, {
            method: "POST",
            headers: {
              "X-Shopify-Access-Token": store.token,
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              inventory_item_id: inventoryId,
              location_id: store.locationId,
              available: item.qty,
            }),
            // @ts-ignore - Add agent to bypass SSL for PTFS
            agent: agent
          }, 3, 5000); // 3 retries with 5 second initial delay

          results.qty = invRes.ok ? "✅ Success" : `❌ ${invRes.statusText}`;
        } catch (err: any) {
          results.qty = `❌ ${err.message}`;
        }
          // Delay 200ms before next item
          await sleep(250);

        // Update price and MRP
        const priceUpdate: Record<string, any> = { id: variantId };
        let needsPriceUpdate = false;

        if (item.price !== undefined && item.price !== "") {
          priceUpdate.price = String(item.price);
          needsPriceUpdate = true;
        }

        if (item.mrp !== undefined && item.mrp !== "") {
          priceUpdate.compare_at_price = String(item.mrp);
          needsPriceUpdate = true;
        }

        if (needsPriceUpdate) {
          try {
            const priceUrl = `https://${store.shop}.myshopify.com/admin/api/2024-10/variants/${variantId}.json`;
            const priceRes = await retryFetch(priceUrl, {
              method: "PUT",
              headers: {
                "X-Shopify-Access-Token": store.token,
                "Content-Type": "application/json",
              },
              body: JSON.stringify({ variant: priceUpdate }),
              // @ts-ignore - Add agent to bypass SSL for PTFS
              agent: agent
            }, 3, 2000); // 3 retries with 2 second initial delay

            const success = priceRes.ok;
            if (item.price !== undefined && item.price !== "") {
              results.price = success ? "✅ Success" : `❌ ${priceRes.statusText}`;
            }
            if (item.mrp !== undefined && item.mrp !== "") {
              results.mrp = success ? "✅ Success" : `❌ ${priceRes.statusText}`;
            }
          } catch (err: any) {
            if (item.price !== undefined && item.price !== "") {
              results.price = `❌ ${err.message}`;
            }
            if (item.mrp !== undefined && item.mrp !== "") {
              results.mrp = `❌ ${err.message}`;
            }
          }
        }
        // Delay 200ms before next item
          await sleep(250);

        status[sku] = results;
      }

      return status;
    },

    // ------------------ Vitashop ------------------
    vitashop: async () => {
      // Import https module for SSL workaround
      const https = await import('https');
      const agent = new https.Agent({
        rejectUnauthorized: false // Bypass SSL verification for Vitashop
      });

      const store = {
        shop: SHOPIFY_VITASHOP_SHOP,
        token: SHOPIFY_VITASHOP_API_TOKEN,
        locationId: SHOPIFY_VITASHOP_LOCATION_ID,
      };

      // Fix the shop URL - ensure it doesn't have double .myshopify.com
      const shopDomain = store.shop.includes('.myshopify.com')
        ? store.shop
        : `${store.shop}.myshopify.com`;

      const status: Record<string, any> = {};

      for (const item of inventory) {
        const sku = normalizeSku(item.sku);
        const variantId = item.asin;
        const inventoryId = item.fsn;

        if (!variantId || !inventoryId) {
          status[sku] = { qty: "❌ Missing IDs", price: "❌", mrp: "❌" };
          continue;
        }

        const results: Record<string, string> = {};

        // Update inventory
        try {
          const invUrl = `https://${shopDomain}/admin/api/2024-10/inventory_levels/set.json`;
          const invRes = await retryFetch(invUrl, {
            method: "POST",
            headers: {
              "X-Shopify-Access-Token": store.token,
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              inventory_item_id: inventoryId,
              location_id: store.locationId,
              available: item.qty,
            }),
            // @ts-ignore - Add agent to bypass SSL for Vitashop
            agent: agent
          }, 3, 2000); // 3 retries with 2 second initial delay

          results.qty = invRes.ok ? "✅ Success" : `❌ ${invRes.statusText}`;
        } catch (err: any) {
          results.qty = `❌ ${err.message}`;
        }
        // Delay 200ms before next item
          await sleep (250);
          
        // Update price and MRP
        const priceUpdate: Record<string, any> = { id: variantId };
        let needsPriceUpdate = false;

        if (item.price !== undefined && item.price !== "") {
          priceUpdate.price = String(item.price);
          needsPriceUpdate = true;
        }

        if (item.mrp !== undefined && item.mrp !== "") {
          priceUpdate.compare_at_price = String(item.mrp);
          needsPriceUpdate = true;
        }

        if (needsPriceUpdate) {
          try {
            const priceUrl = `https://${shopDomain}/admin/api/2024-10/variants/${variantId}.json`;
            const priceRes = await retryFetch(priceUrl, {
              method: "PUT",
              headers: {
                "X-Shopify-Access-Token": store.token,
                "Content-Type": "application/json",
              },
              body: JSON.stringify({ variant: priceUpdate }),
              // @ts-ignore - Add agent to bypass SSL for Vitashop
              agent: agent
            }, 3, 2000); // 3 retries with 2 second initial delay

            const success = priceRes.ok;
            if (item.price !== undefined && item.price !== "") {
              results.price = success ? "✅ Success" : `❌ ${priceRes.statusText}`;
            }
            if (item.mrp !== undefined && item.mrp !== "") {
              results.mrp = success ? "✅ Success" : `❌ ${priceRes.statusText}`;
            }
          } catch (err: any) {
            if (item.price !== undefined && item.price !== "") {
              results.price = `❌ ${err.message}`;
            }
            if (item.mrp !== undefined && item.mrp !== "") {
              results.mrp = `❌ ${err.message}`;
            }
          }
        }

        status[sku] = results;
      }

      return status;
    },

    // ------------------ Naturtint ------------------
    naturtint: async () => {
      // Import https module for SSL workaround
      const https = await import('https');
      const agent = new https.Agent({
        rejectUnauthorized: false // Bypass SSL verification for Naturtint
      });

      const store = {
        shop: SHOPIFY_NATURTINT_SHOP,
        token: SHOPIFY_NATURTINT_API_TOKEN,
        locationId: SHOPIFY_NATURTINT_LOCATION_ID,
      };

      const status: Record<string, any> = {};

      // Check if credentials are configured
      if (!store.shop || !store.token || !store.locationId) {
        console.error("Naturtint credentials missing:", {
          shop: !!store.shop,
          token: !!store.token,
          locationId: !!store.locationId
        });
        return { error: "❌ Naturtint store credentials not configured" };
      }

      // Fix the shop URL if it includes the full domain
      const shopDomain = store.shop.includes('.myshopify.com')
        ? store.shop
        : `${store.shop}.myshopify.com`;

      for (const item of inventory) {
        const sku = normalizeSku(item.sku);
        const variantId = item.asin;
        const inventoryId = item.fsn;

        if (!variantId || !inventoryId) {
          status[sku] = { qty: "❌ Missing IDs", price: "❌", mrp: "❌" };
          continue;
        }

        const results: Record<string, string> = {};

        // Update inventory
        try {
          const invUrl = `https://${shopDomain}/admin/api/2024-10/inventory_levels/set.json`;
          const invRes = await retryFetch(invUrl, {
            method: "POST",
            headers: {
              "X-Shopify-Access-Token": store.token,
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              inventory_item_id: inventoryId,
              location_id: store.locationId,
              available: item.qty,
            }),
            // @ts-ignore - Add agent to bypass SSL for Naturtint
            agent: agent
          }, 3, 2000); // 3 retries with 2 second initial delay

          if (!invRes.ok) {
            const errorText = await invRes.text();
            console.error(`Naturtint inventory error for ${sku}:`, errorText);
            results.qty = `❌ ${invRes.statusText}`;
          } else {
            results.qty = "✅ Success";
          }
        } catch (err: any) {
          console.error(`Naturtint inventory exception for ${sku}:`, err);
          // Check for SSL certificate error
          if (err.cause && err.cause.code === 'UNABLE_TO_GET_ISSUER_CERT_LOCALLY') {
            results.qty = `❌ SSL Certificate issue - check Shopify store URL`;
            console.error('SSL Certificate issue with Naturtint store. Verify the store URL is correct:', store.shop);
          } else {
            results.qty = `❌ ${err.message}`;
          }
        }

        // Update price and MRP
        const priceUpdate: Record<string, any> = { id: variantId };
        let needsPriceUpdate = false;

        if (item.price !== undefined && item.price !== "") {
          priceUpdate.price = String(item.price);
          needsPriceUpdate = true;
        }

        if (item.mrp !== undefined && item.mrp !== "") {
          priceUpdate.compare_at_price = String(item.mrp);
          needsPriceUpdate = true;
        }

        if (needsPriceUpdate) {
          try {
            const priceUrl = `https://${shopDomain}/admin/api/2024-10/variants/${variantId}.json`;
            const priceRes = await retryFetch(priceUrl, {
              method: "PUT",
              headers: {
                "X-Shopify-Access-Token": store.token,
                "Content-Type": "application/json",
              },
              body: JSON.stringify({ variant: priceUpdate }),
              // @ts-ignore - Add agent to bypass SSL for Naturtint
              agent: agent
            }, 3, 2000); // 3 retries with 2 second initial delay

            const success = priceRes.ok;
            if (item.price !== undefined && item.price !== "") {
              results.price = success ? "✅ Success" : `❌ ${priceRes.statusText}`;
            }
            if (item.mrp !== undefined && item.mrp !== "") {
              results.mrp = success ? "✅ Success" : `❌ ${priceRes.statusText}`;
            }
          } catch (err: any) {
            console.error(`Naturtint price exception for ${sku}:`, err);
            if (item.price !== undefined && item.price !== "") {
              results.price = `❌ ${err.message}`;
            }
            if (item.mrp !== undefined && item.mrp !== "") {
              results.mrp = `❌ ${err.message}`;
            }
          }
        }

        status[sku] = results;
      }

      return status;
    },

    // ------------------ Jiomart ------------------
      // ------------------ Jiomart (Excel download) ------------------
      jiomart: async () => {
          const leadTimeUnit = "Days";
          const shippingTimeUnit = "Days";
          const rows = inventory.map(item => ({
              "Variant SKU*": item.sku,
              "Stock SKU*": item.sku,
              "Fulfiller Branch Number*": item["Fulfiller Branch Number"] || "3P2SUOA2FC04",
              "Inventory SKU*": item.sku,
              "Batch Number": item["Batch Number"] || "",
              "Available quantity*": item["Available quantity"] || item.qty || 0,
              "Low Stock Threshold*": item["Low Stock Threshold"] || 5,
              "Multiplier": item["Multiplier"] || 1,
              "Shelf life value": item["Shelf life value"] || "",
              "Shelf life unit": item["Shelf life unit"] || "",
              "Min lead time to source*": item["Min lead time to source"] || 1,
              "Max lead time to source*": item["Max lead time to source"] || 2,
              "Lead time unit*": leadTimeUnit,
              "Min time to ship*": item["Min time to ship"] || 1,
              "Max time to ship*": item["Max time to ship"] || 2,
              "Shipping Time unit*": shippingTimeUnit,
              "Best Before Buy Date": item["Best Before Buy Date"] || "",
              "Manufactured Date": item["Manufactured Date"] || "",
              "Month and Year of Import": item["Month and Year of Import"] || "",
              "Country of Origin*": item["Country of Origin"] || "India",
              "Notes": item["Notes"] || "",
          }));

          const wb = XLSX.utils.book_new();
          const ws = XLSX.utils.json_to_sheet(rows);
          XLSX.utils.book_append_sheet(wb, ws, "inventories");
          const buffer = XLSX.write(wb, { type: "buffer", bookType: "xlsx" });

          return new Response(buffer, {
            headers: {
              "Content-Disposition": "attachment; filename=jiomart_inventory_template.xlsx",
              "Content-Type": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            },
          });
      },

    // ------------------ Amazon ------------------
    amazon: async () => {
      // Amazon WebStock would be implemented here
      // For now, return a placeholder status
      return inventory.reduce((acc: any, item: any) => {
        acc[normalizeSku(item.sku)] = "⏳ Amazon WebStock integration pending";
        return acc;
      }, {});
    },

    // ------------------ Myntra ------------------
    myntra: async () => {
      const status: Record<string, string> = {};
      const batchSize = 10;

      const token = await getToken();
      if (!token) {
        return { error: "Myntra token not found" };
      }

      // Process inventory in batches
      for (let i = 0; i < inventory.length; i += batchSize) {
        const batch = inventory.slice(i, i + batchSize);

        const payload = batch.map((item: any) => ({
          quantity: item.qty,
          sku: item.sku,
          processingSla: item.processingSla || 5,
          store_code: item.storeCode || "MYNTRA"
        }));

        try {
          const res = await retryFetch("https://api-integration.myntra.com/partner/v4/inventory/update", {
            method: "PUT",
            headers: {
              "Content-Type": "application/json",
              "x-partner-store": "Myntra",
              "access_token": token.accessToken,
            },
            body: JSON.stringify(payload),
          }, 3, 1000); // 3 retries with 1.5 second initial delay

          if (res.ok) {
            batch.forEach((item: any) => {
              status[item.sku] = "✅ Success";
            });
          } else {
            const result = await res.text();
            console.error(`Myntra API error (${res.status}):`, result);
            batch.forEach((item: any) => {
              status[item.sku] = `❌ HTTP ${res.status}: ${res.statusText}`;
            });
          }
        } catch (err: any) {
          console.error("Myntra API exception:", err.message);
          batch.forEach((item: any) => {
            status[item.sku] = `❌ Exception: ${err.message}`;
          });
        }

        // Add a small delay between batches to avoid rate limiting
        if (i + batchSize < inventory.length) {
          await new Promise(resolve => setTimeout(resolve, 500));
        }
      }

      return status;
    },
  };

  const handler = handlers[marketplace];
  if (!handler) {
    return json({ error: `Marketplace "${marketplace}" not supported` }, { status: 400 });
  }

  try {
    const result = await handler();

    // Special handling for Jiomart which returns a Response object (Excel file)
    if (marketplace === 'jiomart' && result instanceof Response) {
      return result;
    }

    return json({ status: result });
  } catch (err: any) {
    console.error(`Error updating ${marketplace}:`, err);
    return json({ error: err.message || "Unknown error" }, { status: 500 });
  }
};


async function getToken(): Promise<any> {
    const url = 'https://api-integration.myntra.com/authorization/generate_token';

    console.log('Generating new authentication token');

    const formData = new FormData();
    formData.append('merchant_id', MYNTRA_MERCHANT_ID);

    try {
        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'secret_key': MYNTRA_SECRET_KEY,
            },
            body: formData,
            signal: AbortSignal.timeout(10000),
        });

        if(!response.ok) {
            const error = await response.text().catch(() => 'Unknown error');
            console.log(error);
            return null;
        }

        // Tokens are returned in headers
        const accessToken = response.headers.get('access_token');
        return { accessToken };
    } catch (err: any) {
        console.error('❌ Error:', err.message);
        if (err.cause) console.error('↳ cause:', err.cause);
        return null;
    }
}